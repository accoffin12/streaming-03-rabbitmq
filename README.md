# streaming-03-rabbitmq
> Executed by: A. C. Coffin |
> Completed on: May 2024 | 
> North West Missouri State University

# Overview: 
This project requires some free code - beyond that available in the Python Standard Library. To avoid messing up our local default Python installation, and any other Python projects we may have, we  create a local virtual environment to install and use these libraries.

Think of a virtual environment as a safe sandbox. 
We can install whatever we want in our sandbox, and it won't break other Python projects that may require different versions, etc. 

We use the built-in Python utility `venv` to create our virtual environment. 
There are other options, but this is the simplest and most common. 
We created the environment as a subfolder of this repo named .venv to keep it away from our project code. 

**_Note:_**
To fully understand this repository, please read through the tutorials on the RabbitMQ page. These explain the features, functions, and calls required to run RabbitMQ. 
RabbitMQ Tutorials: [RabbitMQ Hello World! tutorial](https://www.rabbitmq.com/tutorials/tutorial-one-python.html)

**Traditionally Log files are not uploaded to GitHub, however, as this is a streaming project these logs have been left as a way to demonstrate the success of the project.** 

# Table of Contents:
* [Machine Specs and Terminal Information](Machine_Specs_and_Terminal_Information)
* [Prerequisites](Prerequisites)
* [Before You Begin](Before_You_Begin)
* [Executing the Repository](Executing_the_Repository:)
    - [1. Create and Activate a Python Virtual Environment](1._Create_and_Activate_a_Python_Virtual_Environment)
    - [2. Install Dependencies into the Virtual Environment](2._Install_Dependencies_into_the_Virtual_Environment)
        * [A. Pika](A._Pika:)
    - [3. Verify Setup](3._Verify_Setup)
    - [4. Read Producer and Consumer Templates](4._Read_Producer_and_Consumer_Templates)
    - [5. Execute the Producer/Sender](5._Execute_the_Producer/Sender)
    - [6. Execute the Consumer/Listener](6._Execute_the_Consumer/Listener)
    - [7. Open a New Terminal / Emit More Messages](7._Open_a_New_Terminal_/_Emit_More_Messages)
    - [8. Save Time & Effort: Don't Repeat Yourself](8._Save_Time_&_Effort:_Don't_Repeat_Yourselff)
    - [9. Version 2](9._Version_2)




## Machine Specs and Terminal Information:
As everyone approaches a project with a different machine, this repository was completed using Tower with WidowsOS. The specifics are as listed and were pulled from the text document generated by util_about.py. Full results are in the folder util_session_outputs.

> - Operating System: nt Windows 10
> - System Architecture: 64bit
> - Number of CPUs: 12
> - Machine Type: AMD64
> - Python Version: 3.11.4
> - Python Build Date and Compiler: tags/v3.11.4:d2340ef with Jun  7 2023 05:45:37
> - Python Implementation: CPython
> - Terminal Environment:        VS Code
> - Terminal Type:               cmd.exe
> - Preferred command:           python

## Prerequisites
1. Git
2. Python 3.7+ (3.11+ preferred)
3. VS Code Editor
4. VS Code Extension: Python (by Microsoft)
5. RabbitMQ Server installed and running locally

## Before You Begin

1. Fork this starter repo into your GitHub account.
2. Clone your repo down to your machine.
3. Explore your new project repo in VS Code on your local machine.

# Executing the Repository: 
## 1. Create and Activate a Python Virtual Environment

We will create a local Python virtual environment to isolate our project's third-party dependencies from other projects.

1. Open a terminal window in VS Code.
1. Use the built-in Python utility venv to create a new virtual environment named `.venv` in the current directory.

```shell
python -m venv .venv
```

Verify you get a new .venv directory in your project. 
We use .venv as the name to keep it away from our project files. 

In the same VS Code terminal window, activate the virtual environment.

- On Windows, run: `.venv\Scripts\activate`
- On Linux/MacOS, run: `source .venv/bin/activate`

Verify you see the virtual environment name (.venv) in your terminal prompt.

## 2. Install Dependencies into the Virtual Environment

To work with RabbitMQ, we need to install the Pika library.
A library is a collection of code that we can use in our code.
Learning to use free libraries that others have written to make our projects easier, faster, and more reliable is a key skill for a developer.

We keep the list of third-party libraries needed in a file named requirements.txt.
Use the pip utility to install the libraries listed in requirements.txt into our active virtual environment. 

Make sure you can see the .venv name in your terminal prompt before running this:

`python -m pip install -r requirements.txt`

### A. Pika:
Pika is a Python implementation of the Advanced Message Queueing Protocol or AMQP 0-9-1. It supports Python 3.7 + and allows us to utilize RabbitMQ. Additionally, Pika does not require threads, but the core will not forbid them if used. This Library enables the user to address greenlets, callbacks, continuation, and generators. Multiple connections are also possible through the instance pika.ConnectionParameters, this includes control over connection attempts and retry delays. 

Finally, it is important to note that when Pika is requesting message acknowledgments from another thread an individual Pika connection adapter instance may result in a dropped AMQP/stream connection due to a heartbeat timeout in consumers that takes too long to process the incoming message. Pika allows for the delegation of processing incoming messages to another thread while the connection adapter thread continues to service the message pump to maintain timely responses. The code running on the secondary thread may request the ack_message() function to be executed in the connection adapter's thread. There are several mechanics to do this the ones highlighted in this repository are:

```
pika.BlockingConnection() 
pika.ConnectionParameters() 
auto_ack 
```
For full list of protected terms, classes and functions see [Official Pika Documentation](https://pika.readthedocs.io/en/stable/).
| Pika Class and Modules| Type | Use |
| ---------- |  ---------- | ---------- |
| BlockingConnection() | Class | A synchronous adapter for abstracting the I/O loop from the application and exposes the connection|
| ConnectionParameters() | Class| Encapsulated Authentication Credentials allowing us to dictate the Host. |
| ack_message | function | Executed in the connection adapters loop using a specific mechanism, it is possible to automatically generate using auto_ack. |
| Channel | Class | Used to communicate with RabbitMQ via AMQP RPC methods, the primary communication method for interacting with RabbitMQ. |

## 3. Verify Setup

In your VS Code terminal window, run the following commands to help verify your setup.
These util files MAY be helpful to ensure you're set up correctly. 
You may have a different configuration and RabbitMQ may still work; the check looks in common places, but may not work for all installations. 
They are meant to be helpful but are not required.

```shell
python util_about.py
python util_aboutenv.py
python util_aboutrabbit.py
pip list
```

Note: The util_aboutrabbit.py will only work on machines with Cholocaty installed. Windows requires a different locator to find where Rabbit has been installed. 

![verifying setup](./images/verify-setup.png)


## 4. Read Producer and Consumer Templates
Read the code and comments in our 2 project files: emit_send.py and listen_recieve.py

Don't worry if it doesn't all make sense the first time. 
Approach it like a puzzle and see what you can figure out. Examine how functions are assembled as well as the use of Pika, this will assist in understanding Steps 6 through 7. Especially pay attention to the use of the Pika library such as: `connection`, `channel`, `queue_declare`, and `basic_publish`. Each of these is critical to code running properly. Please see the section [A. Pika](A._Pika) for information on the library and official documentation.  

# Version 1:
## 5. Execute the Producer/Sender

1. Read v1_emit_message.py (and the tutorial)
2. Run the file. 

It will run, emit a message to the named RabbitMQ queue, and finish.
We can execute additional commands in the terminal as soon as it finishes. 
Be sure that **_RabbitMQ is running_** while executing these commands, otherwise, the scripts will not run. 


## 6. Execute the Consumer/Listener

1. Read v1_listen_for_messages.py (and the tutorial)
2. Run the file.

When running both scripts in a split terminal, the results should look as follows. The terminal on the left is emit_sent.py and the terminal on the right is listern_recieve.py. Notice how both of these terminals are responding. The message from the left (emit) can be seen being received on the right (listen). To terminate the code utilize the built-in termination call, Ctrl + C. This will end the streaming process. Also, each terminal is treated like an individual queue, so when altering messages save the code and open a new terminal. 

As long as the process is running, the terminal can not be used for other commands. 

![2 Terminals running emit_send and listen_recieve](/ProjectScreenShots/v1RunwithCorrection.PNG "v1 Running with Corrections")

## 7. Open a New Terminal / Emit More Messages

1. Open a new terminal window.
2. Use this new window to run emit_message.py again.
3. Watch the listing terminal - what do you see?  A second message?

### Results:
![3 Terminals running 1 emit_send and 2 listen_recieve](/ProjectScreenShots/v1RunMultiTeminals.PNG "v1 Running with Multiple Terminals")

The second message that can be seen is a waiting message, as the script emit_send.py only contains a single message and routing key. This means that even though we have sent a message using terminal 1, we did not send a fanout message - which ignores these keys. Instead, the message was direct and received by the intended queue - terminal 2. Therefore Terminal 3 will wait until Terminal 1 has run the script again to send the message. 

Sending the same message each time is kind of boring. This time:

4. Where is the message defined? How can you change it?
5. Modify emit_message.py to emit a different message. 
6. Execute the updated emit_message.py. 
7. Watch what happens in the listening terminal.

Repeat this process several times - emit at least 4 different messages.
Don't worry - it's just code. We can always revert back (try the 'undo' command in VS Code) to a version that works. You can't hurt anything. 

### Results:
The message is defined in several places, the first being `body=""` and the second is actually where we instruct the script to write a message in the consol, line 23 which is:
```
print(" [x] Sent 'Hello World!'")"
```
 While maintaining the original queues and terminal any message modified within this specific script will be sent to the original pair of terminals. Even though the contents of the message are different each time, alterations to the body have to be done - so long as the receiving queues have the same key the message will be received on these queues. 
 
 This is explored more when examining v2_emit_message.py.

## 8. Save Time & Effort: Don't Repeat Yourself

Did you notice you had to change the message in TWO places?

1. You update the actual message sent. 
2. You also update what is displayed to the user. 
3. Fix this by introducing a variable to hold the message. 
4. Use your variable when sending. 
5. Use the variable again when displaying to the user. 

Now, to send a new message, you'll only make ONE change.
Updating and improving code is called 'refactoring'. 
Use your skills to keep coding enjoyable. 
This can also be observed in the attached logs folder within this repository.



# 9. Version 2

Now look at the second version of each file.
These include more graceful error handling,
and a consistent, reusable approach to building code.

Each of the version 2 programs includes an error as well. 


1. Find the error and fix it. 
2. Compare the structure of the version 2 files. 
3. Modify the docstrings on all your files.
4. Include your name and the date.
5. Imports always go at the top, just after the file docstring.
7. Then, define your functions.
8. Functions are reusable logic blocks.
9. Everything the function needs comes in through the arguments.
10. A function may - or may not - return a value. 
11. When we open a connection, we should close the connection.  
12. Learn and understand this common Python idiom.

### Results and Coding Tips:
After fixing both v2_emit_message.py and v2_listen_for_messages.py, both were run multiple times. Each time the message was changed, the number of terminals was also changed. For runs 2 and 3, one terminal was emitting the message, and 2 were set up to receive the message. Each of these runs has a corresponding screenshot found within the [ProjectScreenShots Folder](/ProjectScreenShots/). The log from these runs has also been added to the repository as verification that the terminals were working properly.

The last run:
![v2Mod2R3TCoffee](/ProjectScreenShots/v2Mod2R3TCoffee.PNG "Final Shot of v2 run with coffee message - I still can't find that cup by the way.")


#### Coding Tips:
When writing out imports keep these as individual lines - similar to a grocery list. This is done for two major reasons, the first is that it makes code readable. Readability gives those existing or examining it the ability to note each of the libraries required or if the script requires another script to be brought in from a different location in the repository. Creating a "Grocery List" improves the maintainability of the code, especially when there is more than one developer on the project. 

Closing connections is important, especially when dealing with servers and streaming data. If a server isn't told to close a connection it will continue consuming CPU space, which can lead to disastrous consequences. It can be even more irritating if a connection is left open while attempting to shut down a computer. Always when writing a consumer/listener script the line `conn.closed()` or `connection.closed()` is included. 

`__name__ == "__main__"` is a top-level code environment of the program. It enables developers to determine how a user interacts with modules, and how modules interact. This code is the first users-specified Python module that starts running, meaning that it imports all other modules that the program needs. This particular one is a boilerplate code, it's designed to check its own `__name__`, creating a common idiom, conditionally executing code when the module is not initialized from an import statement. It prevents us from pulling from the wrong module, forcing us to parse command line arguments or fetch data from a standard input. The code in this block will not run unless the top-level environment module is executed. 


## Reference

- [RabbitMQ Tutorial - Hello, World!](https://www.rabbitmq.com/tutorials/tutorial-one-python.html)
- [Using Python environments in VS Code](https://code.visualstudio.com/docs/python/environments)
- [RabbitMQ Get Started](https://www.rabbitmq.com/#getstarted)
- [Pika GitHub Repo](https://github.com/pika/pika)
- [Pika Documentation](https://pika.readthedocs.io/en/stable/)
- [Python Documentation Library for Top-Level Enviroments](https://docs.python.org/3/library/__main__.html)

![Exploring the local virtual environment folder](./images/exploring_dot_venv.PNG)
